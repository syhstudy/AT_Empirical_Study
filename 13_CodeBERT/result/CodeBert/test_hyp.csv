move ecx to edx
move dl into the single byte at the address stored in ecx+92
push the value of register eax onto the stack
push the byte +0x8 onto the stack
subtract 15 from the contents of the dx register
initialize the esi register with the decimal value 0
declare the setup label
define the byte string '/sbin/iptables#'
move the word in ax into the memory location specified by the operation [ebp+22]
push 0x6f675f64 onto the stack
move 0x9a8d1 into eax
make the system call alarm
make the socketcall
jump to the incpage label if the contents of the al register is equal to the value 0xf2
push the sys_execve onto the stack
move 0xcd into al
declare the shellcode label
jump to incaddr if no match
push 0xefffff7f onto the stack
move the contents of the esp register into the ebp register
perform a logical xor between the byte at the address speicified by [esi+ecx] and the bx register and the byte value 0x0x0f]
put the byte chmod_call into the eax register
declare the global _star
jump to the decoded_shellcode label if the zero flag is set
define an array of word and initialize it to 5
put the syscall 0xc into the eax register
subtract 0x63746e from the contents in ecx and save the result in ecx
load the effective address of the result of the operation [zero_reg+3] into the eax register
if the byte starting at the address contained in the esi register is lower than the byte value 0x7 then jump to the lowbound label
decrement ecx and jumps to the fill label unless decrementing ecx caused its value to become zero
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else move the value 0x4 into the al register
push 0x746973 to the stack
move the contents of the esi register into the bx register
zero out the ax register
get the process id
push the value of register eax onto the stack
get the parent process id
define the array of bytes encodedshellcode and initialize it to 0x30
negate all the byte at the memory location var
negate all the bits of the eax register
define the byte string 'egg mark'
jump short to the process label
move the contents of the eax register into the long starting at the address [esi+30]
remove last character from the stack into ebx
sigaction
move cl into bl
increment ebx register
right shift the contents of the edx register by the byte 16
declare section containing uninitialized data
declare a constant size and set equal to 255
push 0x2f3a746f onto the stack
jump short to the stage label
jump to the dup2 label if the previous instruction clears the sign flag
jump to _star label
declare the set_arg label
push the word 0x697a onto the stack
perform the xor operation between cl and 0xaa and store the result in cl
move 0x7f into dl
push the contents of the eax register onto the stack and point edx to the stack register
multiply eax by ebx
jump to 0x86
load the effective address of the result of the operation [zero_reg+117] into the ecx register
right shift the contents of the dl register by 1 bit
subtract 0x2e2aa163 from ebx and save the result into ebx
call the ecx register
jump to the infinite label if the contents of the eax register is not equal to the contents of the edi register
move the byte at the address 0ffh into dl
move 0x06 into al
declare the entrypoint label
mask out lowest 4 bits of the eax register
move al into the byte at address [esi+12]
push the contents of the esi register onto the stack.
declare the array of bytes and initialize it to 1534
define msg variable
if the contents of the eax register is not zero then jump to the label l1 else call the function myfunct
push the contents of the esi register onto the stack and point eax to the stack register
specify sys_write syscall
push the 0x4 onto the stack
remove last character from the stack into eax
push 0x0a4c4c41 onto the stack
if the unsigned contents of the cl register is lower than the unsigned value 0x11 then jump to the memory address 0x11 else add the 0x10 into the cl register
get the parent process id
jump short to the _file label
move the contents of memory address ebx+epi*4+2 into eax
declare 6 bytes starting at the address str initialized to the ascii character values for hello and the null byte
system call exit
put the syscall 6 into the eax register
multiply eax by the contents of the edx register
move filename into ebx
move bl into the single byte at the address stored in esi+ecx
move the contents of the ebp register into the esp register
move value of ax into ax
push 0x3a3a3a onto the stack
zero out the ax register
push bx onto the stack
make the system call to copy the file descriptor
jump short to the search label
push the byte 54 onto the stack
push the contents of the edi register onto the stack and point ebx to the stack register
jump to the _return label
add the contents of the eax register to the contents of eax register
jump short to the call label
move 0x72702f2f into esi
compare the contents of the eax register and the contents of the ebx register
divide ecx by 2 using right shift
jump to the label loop_1 if the first byte of the esi register is not equal to the contents of the bl register
define msg variable and initialize with 'i love you!'
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else point the ebx register to the stack register
declare the close label
push the contents of the ecx register onto the stack.
pop the top of the stack into the edx register
move the contents of the cl register into the cl register
jump to the l2 label if the byte starting at the address contained in the edx register is not equal to the byte value 0x2e else jump to the while label
left rotate the edx register 4 times
push the double word 0x243836c onto the stack
create the doubleword variable z in memory and initialize it to zero
declare the start label
increment the contents of the ax register
move the byte in eax into bl
restore the top of the stack into the cx register
zero out the eax register
push ebx to the stack
move the byte at the address [esi] into bl
push 0x622f7273 onto the stack
push the byte 10 onto the stack
move 0xfff into cx
make the system call kill
perform the xor operation between the eax register and 0xffffffff
jump to the while label if the doubleword starting at the address contained in the edx register is equal to the doubleword value 0x636f7270
move 6 into al
move eax into edi
move decimal number 3 into edx
declare the shell_ret label
move 05h into al
move esi into the doubleword starting at the address esp-4
push the dword 0x7264632f onto the stack
if the byte starting at the address contained in the esi register is lower than the byte value 0xd then jump to the wrap_around label
add the contents of the edi register to the contents of the edi register
specify sys_write syscall
push double word 0x61732f2f and the double word 0x7273752f onto the stack and point the ebx register to the stack register
move 102 into al
increment the contents of the bl register
if the doubleword starting at the address contained in the eax register is not equal to the contents of the edx register then jump to the loop label else jump to the eax register
decrement the contents of the ecx register
push the value 0x61702f2f and the value 0x6374652f onto the stack and point the eax register to the stack register
execute execve syscall
perform the xor operation between the value stored at the location ecx and dh
move /bin/sh into the edx register
subtract 15 from the contents of the dx register
compare the contents of the al register with the value 0xf2
call the writestring function
move ascii /bin/sh into ecx
declare the even_number label
invoke sys_open
add the contents of esi to the contents of eax
push the 0x6e69622f onto the stack
decrement the contents of the ecx register and jump to the label if the result is not zero
add 32 to the contents of the edx register
declare a word and initialize it to 12-8
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero else point the ebx register to the stack register
declare the dup2 label
move 2 into bl
add the byte value 64 to the memory location var_value
define egg1 equal to 'egg mark'
push the word 0x5c11 to the stack
jump to the loop label
decrement the counter and jump to the l1 label if the count is not zero and the zero flag is set to zero
define the callit label
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else jump to the exit label
push esp to the stack
push the value 0x6e69622f and the value 0x7273752f onto the stack and point the ecx register to the stack register
if the contents of the eax register is negative then jump to the label close
section data
divide the contents of the esi register by the contents of the esi register
exchange ecx with edx
define the doubleword arr and initialize it to 20
divide eax by edx
subtract 13 from the contents of the ax register
call the _appendfile function
call the esp function
put the syscall 0x43 into the eax register
jump to the memory address 0x40 if the contents of the al register is equal to the value 0x40 else push the byte representation of the stack
move eatlen into edx
push the word [edx] to the stack
move 0x22f3a31 into esi
move the contents of the al register into the edi register
add 0xa to the al register
jump to the _start label if the contents of the al register is zero
move the contents of the ebx register into the long starting at the address [esi+26]
declare the shell label
move 0x2 into dl
push the contents of the esi register onto the stack.
define the exit label
push 0x61702f63 onto the stack
push the value 0x687373 onto the stack
move 25 into the effective address saved in ecx
push 0x1c onto the stack
jump to the next_cycle label if the result of the logical xor between the dl register and the value 0xbb is zero
call the execute function
write to the stdout file
move 15 into al
reserve 1 word for variablename1
define string as the byte string 'file.txt'
push the byte 0x1f onto the stack
push the 0x204c4c41 onto the stack
define me label
move readbuffer into ecx
jump to the label write if the contents of the eax register is zero else zero out the contents of the eax register
push the value 0x0 to the stack
move the byte in esi into cl
push the dword 0x6e6e onto the stack
move 0x9179 into esi
define message string 'hello world!'
move the 4h into ax
jump to the top of the stack label if the zero flag is cleared
move the contents of the esp register into the ebx register
make the system call to suspend the process
jump to the esp label
put the syscall 9 into the eax register
declare the close label
push the dword 0x73656c62 onto the stack
move v_src to esi
if the contents of the eax register is zero then jump short to the memory location loc_402c13
declare the set_arg label
move 0xe into bl
push the byte 3 onto the stack and point ebx to the stack register
right shift the contents of the ebx register by 31 bits
move the byte at the address [edi] into bl
move 4 into ebx
invoke sys_close
divide eax by 2 using right shift
define the _dup2_loop label
left rotate the contents of the edi register by 1 bit
move 01 into cl
make the system call alarm
jump to the label l1 if the contents of the al register is greater than or equal to the decimal value 9
move 0x1000 into eax
put the syscall 0x64 into the eax register
move the byte in eax into bl
move ebx into the address [esp+59]
declare a byte with no label containing the value 10
decrement the ecx register and jump to the l2 label if the contents of the ecx register is not zero and the zero flag is zero else jump to the edi register
move 0100 into ax
jump to the exit label if the contents of the eax register is equal to the contents of the ebx register else jump to the exit label
push the value of register eax onto the stack
right rotate the byte in esi 1 time
push the value 0x6374652f onto the stack and point ecx to the stack register
move 61 into al
section data
zero out ebx
exchange eax with ebx
make the system call kill
push the value 0x68732f2f onto the stack
set the direction flag to zero
push 0x6873732f to the stack
push the value 0x6e7a762d onto the stack and point the edi register to the stack register
call the sprintlf function
move the number of bytes of var3 into ebx
make the system call to the kernel
move 13 into cl
write to the stdin file
if the contents of the eax register is negative then jump to the label old_dirent
push 0x74 to the stack
declare section containing code
increment the contents of the dx register
load the effective address of the result of the operation [esi + 12] into the edx register
move the the the contents of the bl register into the byte starting at the address in edi
push the word 0x1b6 to the stack
push '/bin/sh' onto the stack
move stack pointer to eax
push 0x10 onto the stack
swap the address [ebp+16] with the contents of the ecx register
declare the exit_on_error label
perform and operation between al and 0fh
declare the format label
declare the end label
reserve 1 word for variablename1
left rotate the byte at the address esi by 4 bits
decrement ecx and jumps to the loop label unless decrementing ecx caused its value 3
invoke sys_close
move the value 0x2 into the cl register
jump to the label do_inject if the byte representation of 2 is equal to the contents of the al register else jump to the while label
move address of stack pointer into edx
move the number of bytes of eax into eax
get the parent process id
define string as the byte string 'file.txt'
push 0x3c4c41 onto the stack
put the address of ebx+0xf into eax
move 3 into bl
define the byte string '/usr/bin/sh#'
negate all bits in the byte at the memory location var2
declare the incpage label
push the value of register eax onto the stack
move esi into ecx
jump to the label write if the contents of the eax register is zero else zero out the contents of the eax register
jump to the read label
jump to the label next_page if the contents of the al register is equal to the value 0xf2
if the contents of the eax register is not zero then jump to the label checkforfile
push 0x6d722f2f onto the stack
move address of stack pointer into edx
if the contents of the eax register is not zero then jump to the label l4 else call the function search
left shift the contents of the ecx register by 2 bits
push the value 0x64687373 onto the stack and point the eax register to the stack register
add one to the doubleword integer stored at memory location var
move 9 into cl
push 0x64687373 onto the stack
load the effective address of the result of the operation [zero_reg+6] into the eax register
push 0x0a206873 onto the stack
jump to the shift_decode label if the zero flag is set
define the doubleword variable neg_number and initialize it to 50
move the 4th element of the array word_table into cx
define msg variable and initialize it to 'hello world!'
call the two function
if the contents of the eax register is zero then jump to the label ready_to_proxy
move zero_reg into ebx
move 0xb into al
specify sys_write syscall
declare the next label
move the contents of dl into the byte at the memory location specified by the operation [esi+1]
push the byte 16 onto the stack
